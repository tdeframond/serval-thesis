\chapter{Results and discussion}

The main part of my work and results are availaible on the Github repository I introduced in Chapter 4. We can find there the codes and the scripts I have written.
\par
Results are like expected scripts we can run on a laptop to test the Serval Mesh Extender. The first one works very well and, as expected, we can run it without issues and update the firmware of any Mesh Extender with the image we want. We can use it by just running the command :
\\ > ./nom-du-test.exp \\
To improve the testing experience, we should automate this test without rebooting manually the PCB. Indeed, to start or boot it, we have to manually replug it, to shut it OFF and ON again. We should be able to do it automatically in the future by adding a switch on the "hardware test unit" that Ryan was suppose to develop and in which will be plugged the PCB. With this, we will be able to command from the outside and without human interactions the boot of the PCB that will allow us to run all the tests in a row. 

\par
I finished to code the second script for the connections check at the same time Paul released a new version of the Mesh Extender software. This new version was better in terms of functionality but brought a big issue in my code. Indeed this update is communicating with Lbard, which is a good thing. But it also prints on the standard output every single piece of signaling characters that the communication produce. And this is not good because Expect is monitoring every characters on this output. It appeared that some special combination of these special characters was a secret command of expect that makes it stop running or exit the program... Since this moment I could not do anything because I was not able to test my tests myself and even just run them. 
\\
I learned here something really important. When you are coding something which depends or interact with an other software or device, you should definitely take into consideration the fact that this second software could change anytime in a way or another as with this serious update. Next time, I will consider this thing more seriously and try to develop something more universal or easier to adapt to changes. I understand now why programs have to be written clearly and in an easy way to understand the philosophy of it. It is because we need to adapt to the exterior environment. Therefore we also need a flexible program. 

\par 
I did not know at all that I was lacking of time. But this is a real thing that every little notion you have to learn take so much time. It is exactly the same with informatics issues and bugs. When something does not work in your code or if you can not managed to install a software, this take an humongous quantity of time. For example I have been stuck for one week by just wanted to install the openWRT image creator on my laptop. What was at first just a software installation turned into a giant puzzle. Indeed for some mysterious reason this distribution can not be created from a mac. I had then to install a Linux Virtual Box and to install the distribution on it. First lost of time, it took one entire day just to create the image. After this, there is still the problem