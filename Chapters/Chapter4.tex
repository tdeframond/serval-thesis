\chapter{Method and Material}

\section{General Functioning}
\subsection{Management}
My master project is a bit special in a sense that it is not my personal project. I chose to join an existing one. That means that I have to follow the rules who already run the telecommunication laboratory where I work. At the moment we are a dozen of students/researcher working here on either independent projects either some linked project. As far as I am concerned, Paul and Jeremy are working on the Serval Project as well but I am the only one student working on the tests this semester. Usually they are many French students as the same time and they can therefore help each other, which I can obviously not since I am the only one.

\par
Paul is the laboratory director. To keep himself updated with all the projects of his students and fellow, he organizes every Monday a "Lab Meeting" at 2.00pm. Everyone has to be here in order to make a brief summary of its work progress by presenting a three point report: "what I did last week, what I will do next week, do I have difficulties ?". This helps him to know the ones who are late, blocked or unwilling to work and the ones who are motivated.

\par
There is no really strict rules concerning the management of my project. Paul just let me know what he was waiting for and what did I have to do. I am quiet free to handle it as I want as far as I finish the work. Therefore I decided to just take care of one task after the other by following a procedure which I will explain in the next section of this chapter. 

\subsection{Means and documentation}
As a master student, I can access the laboratory from 6am to 10pm all the week with my student card. In there, I can use lots of different equipment like laptops, screen monitors, tools, phones, printers, antenna ...etc. Some documentations is also available and blackboards help us to brainstorm and through quick drafts on them.
\par
The Serval documentation can be found in three different places: internet, papers and local pdf documents. 
\\
On internet we can find first the Serval website which is kind of public access to the project with simple and "business" explications. Second we have the Serval wiki which is the developers documentation side of the project. It explains everything with more technical details. As Serval is an open source project, this wiki is quiet exhaustive and obviously completed by a Github repository where all the codes of Serval is stored and totally public. Everyone can access it and add some modification to it. I spent quiet a lot of time to read the wiki in order to learn how Serval work and I also had to clone some depo from the Github to install and work on it. Finally, Paul owns a blog where he posts every step of the project. It may be the place the more up to date and the more illustrate with pictures. This is where we can follow the adventure in real time. A Google group also exists but it is not very active. I tried to start one discussion about my project but got no response.
\\
Finally, the best way for me to find informations was face to face discussions in the laboratory. Although the community is almost inexistent and inactive on the web, Paul and Jeremy were very helpful in the lab and were happy to answered my questions. Nothing is better than real human contacts. It was at beginning really hard for me to understand my fellows because of their strong Aussie accent and their fast speaking. Added to the fact that I did not know anything about Serval and the technologies I had to use, it was really hard to jump in the bath. I had to ask them to slow down a bit for me because I could not understand anything. After five months in Australia, it is now easier for me to understand them.  

\section{Test methodology} 
My work methodology is following an Agile method. Every tests can be considered as a single task or a user-story such as my supervisor can be considered as the scrum-master. Each time I chose a new ticket, I try to chose a deadline to fix the ticket according to its complexity. Obviously it is not often easy for me to respect this delay since I am not familiar with the technologies I have to use here. For example, a really simple task can take me a huge amount of time to execute because of my lack of knowledge in these new languages. \\   
The test methodology is not completely defined and can be different depending on the test himself. Nonetheless, the global aspect follows the same basic pattern every time.

\subsection{Test technology}
\subsubsection{Bash}
As Serval project use lots of different languages and devices, we can not use a normal test frameworks like JUnit for example. Indeed we are not doing a test driven development or just testing codes. My goal in this project is to test the whole thing, not just some codes. This is why I need to use something more general and less specialized than a test framework. To this end, I will use basics shell scripts which are very useful to communicate with the Mesh Extender since it is running on a Linux kernel. Bash is the most famous and simple shell language that I can use. It allows me to call directly lots of Linux command and high level instructions. This is very practical with what concerns Wi-Fi connections for example. 

\subsubsection{Expect}
Expect is a tool for automating interactive applications such as telnet, ftp, passwd, fsck, rlogin, tip, etc. Expect really makes this shells interactions trivial. It is also useful for testing these same applications. And by adding Tk, we can also wrap interactive applications in X11 GUIs, but this won't be useful in my case. Expect can make easy all sorts of tasks that are prohibitively difficult with anything else.\\
I was first thinking that it was a useless tool but after using it, I realized that it was not the case at all and that it really helps with my tests. Moreover I even found myself using expect for others purposes like automate my thesis save on Github. Now, with my simple Expect script I can add, commit and push my thesis on the repository with just one script without having to enter my Github password or commit message. 
\par
Expect is based on the TCL language, so I had to learn this one as well before starting to use it. Expect add some new command to TCL that are really helpful for automation like the commands : spawn, expect and send. Basically and the most easier way to understand it is as follow. First you start and open a shell command with the "spawn" command, then you wait the shell to respond a particular message with the "expect" command and you react according to this respond with the "send" command which actually just type something for you automatically in the shell. 

\subsection{Test overlook} 
The first task to do before each test is to sort it and classify it between hardware and software categories. This also helps to chose which language will be more adequate to test it and in which environment I have to code it. Sometimes just a bash script will be enough to reach my goal, sometimes I will need an expect script to go further. Sometimes expect does not react like it is supposed to with the Mesh Extender, and I have thus to fix this issue by just using the shell. \\
This is also the phase in which I will talk with my supervisor Paul in order that he explains me all the aspects of the tests and what are his expectations. This is a kind of user story creation where we establish the goals and the tasks to implement in the test.

\subsection{Tools}
To write my tests I just need a text editor and the terminal. My favorite text editor is Sublime Text. It is very light and helpful with everything. I use it to write either my thesis in Latex or either my Expect and Bash script. It has an auto-completion feature and an integrated spell checker which is really interesting for my thesis writing. 
\begin{wrapfigure}{l}{0.15\textwidth}
    \centering
    \includegraphics[width=0.15\textwidth]{sublime}
\end{wrapfigure}
\\
Before getting started with the development I had to install my environment. Serval OpenWRT which is a light Linux distribution used by the Mesh Extender was the first package I have to install on my laptop in order to create and export the Linux disc image on the PCB. I also had to install Expect of course and many different other tools like for instance Airport which offer a wifi scan service from the shell which will help me with testing the wireless connections.
\begin{wrapfigure}{r}{0.15\textwidth}
    \centering
    \includegraphics[width=0.15\textwidth]{github}
\end{wrapfigure}
\par
I have a personal Github repository to save and share all my thesis work. Here is the link : https://github.com/tdeframond/mesh-extender-provisioning .
\begin{wrapfigure}{l}{0.15\textwidth}
    \centering
    \includegraphics[width=0.15\textwidth]{openwrt}
\end{wrapfigure}
\\
I also created a discussion on the Serval Google group about my work to try to interact with other member of the project : https://groups.google.com/forum/\#!topic/serval-project-developers/qUYktshW1x4 . 

\subsection{Tests pattern}
My tests are just scripts written as follow : one small script per test so it is easier to code and organize them. Each Expect script is therefore a text file with the name of the test and an 
".exp" extension. These Expect scripts can make use of other small Bash script for special tasks. 
\\
There is no input for the moment, I will have to implement that later. If the script needs some inputs, It have them directly in its code. The scripts are thus not really instantaneous adaptable to different Mesh Extender. For example if the test need the mac address of the Mesh Extender, I will give it to him in the code. In the future it would be better that the script can retrieve it automatically.
\\
I design all the outputs with the same graphic charts in order to have a unity in the tests. This is a really simple design pattern made of \# and > but it is simple, clear and easy to exploit and understand. These outputs keep us knowing how is the test going throughout the whole testing and display the final results at the end. Each specific test has its own and separate output but the goals in the end of the project would be to join all this small tests in a bigger one so we can launch all of them with one command and see all their results in a one place. 
